/**
 * Outstatic Type Generator
 *
 * Generates TypeScript types from collection/singleton schemas.
 * Supports field projection for narrowed return types.
 */

import fs from 'fs'
import path from 'path'
import { Schema, schemaToInterface, slugToInterfaceName } from './schema-to-ts'

export interface GenerateTypesOptions {
  /** Path to the content directory (default: 'outstatic/content') */
  contentPath?: string
  /** Path to output generated types (default: '.outstatic/types') */
  outputPath?: string
  /** Current working directory (default: process.cwd()) */
  cwd?: string
}

interface CollectionInfo {
  slug: string
  interfaceName: string
  schema: Schema | null
  isSingleton: boolean
}

const DEFAULT_CONTENT_PATH = 'outstatic/content'
const DEFAULT_OUTPUT_PATH = '.outstatic/types'
const SINGLETONS_DIR = '_singletons'

/**
 * Discovers all collections in the content directory
 */
function discoverCollections(contentPath: string): CollectionInfo[] {
  const collections: CollectionInfo[] = []

  if (!fs.existsSync(contentPath)) {
    return collections
  }

  const entries = fs.readdirSync(contentPath, { withFileTypes: true })

  for (const entry of entries) {
    if (!entry.isDirectory()) continue
    if (entry.name.startsWith('.')) continue
    if (entry.name === SINGLETONS_DIR) continue

    const schemaPath = path.join(contentPath, entry.name, 'schema.json')
    let schema: Schema | null = null

    if (fs.existsSync(schemaPath)) {
      try {
        const content = fs.readFileSync(schemaPath, 'utf-8')
        schema = JSON.parse(content) as Schema
      } catch (e) {
        console.warn(
          `Failed to parse schema for collection "${entry.name}":`,
          e
        )
      }
    }

    collections.push({
      slug: entry.name,
      interfaceName: slugToInterfaceName(entry.name),
      schema,
      isSingleton: false
    })
  }

  return collections
}

/**
 * Discovers all singletons in the _singletons directory
 */
function discoverSingletons(contentPath: string): CollectionInfo[] {
  const singletons: CollectionInfo[] = []
  const singletonsPath = path.join(contentPath, SINGLETONS_DIR)

  if (!fs.existsSync(singletonsPath)) {
    return singletons
  }

  const entries = fs.readdirSync(singletonsPath, { withFileTypes: true })

  for (const entry of entries) {
    if (!entry.isFile()) continue
    if (!entry.name.endsWith('.schema.json')) continue

    const slug = entry.name.replace('.schema.json', '')
    const schemaPath = path.join(singletonsPath, entry.name)
    let schema: Schema | null = null

    try {
      const content = fs.readFileSync(schemaPath, 'utf-8')
      schema = JSON.parse(content) as Schema
    } catch (e) {
      console.warn(`Failed to parse schema for singleton "${slug}":`, e)
    }

    singletons.push({
      slug,
      interfaceName: slugToInterfaceName(slug),
      schema,
      isSingleton: true
    })
  }

  return singletons
}

/**
 * Generates a type file for a collection or singleton
 */
function generateTypeFile(info: CollectionInfo): string {
  const lines: string[] = []

  lines.push(`// Generated by Outstatic - do not edit manually`)
  lines.push(`import type { OstDocument } from 'outstatic'`)
  lines.push('')

  if (info.schema && Object.keys(info.schema.properties || {}).length > 0) {
    lines.push(schemaToInterface(info.schema, info.interfaceName))
    lines.push('')
    lines.push(
      `export interface ${info.interfaceName} extends OstDocument<${info.interfaceName}Fields> {}`
    )
  } else {
    // No custom fields, just use base OstDocument
    lines.push(`export interface ${info.interfaceName}Fields {}`)
    lines.push('')
    lines.push(
      `export interface ${info.interfaceName} extends OstDocument<${info.interfaceName}Fields> {}`
    )
  }

  lines.push('')
  lines.push(
    `export type ${info.interfaceName}Field = keyof ${info.interfaceName}`
  )
  lines.push('')

  return lines.join('\n')
}

/**
 * Generates the collections.ts file with union types
 */
function generateCollectionsFile(
  collections: CollectionInfo[],
  singletons: CollectionInfo[]
): string {
  const lines: string[] = []

  lines.push(`// Generated by Outstatic - do not edit manually`)
  lines.push('')

  // Import all collection types
  for (const col of collections) {
    lines.push(
      `import type { ${col.interfaceName}, ${col.interfaceName}Fields } from './${col.slug}'`
    )
  }

  // Import singleton types
  for (const singleton of singletons) {
    lines.push(
      `import type { ${singleton.interfaceName}, ${singleton.interfaceName}Fields } from './_singletons/${singleton.slug}'`
    )
  }

  lines.push('')

  // Collection name union
  if (collections.length > 0) {
    const collectionNames = collections.map((c) => `'${c.slug}'`).join(' | ')
    lines.push(`export type CollectionName = ${collectionNames}`)
  } else {
    lines.push(`export type CollectionName = never`)
  }
  lines.push('')

  // Singleton name union
  if (singletons.length > 0) {
    const singletonNames = singletons.map((s) => `'${s.slug}'`).join(' | ')
    lines.push(`export type SingletonName = ${singletonNames}`)
  } else {
    lines.push(`export type SingletonName = never`)
  }
  lines.push('')

  // Collections type map
  lines.push(`export interface Collections {`)
  for (const col of collections) {
    lines.push(`  '${col.slug}': ${col.interfaceName}`)
  }
  lines.push(`}`)
  lines.push('')

  // Singletons type map
  lines.push(`export interface Singletons {`)
  for (const singleton of singletons) {
    lines.push(`  '${singleton.slug}': ${singleton.interfaceName}`)
  }
  lines.push(`}`)
  lines.push('')

  // Helper types
  lines.push(
    `export type CollectionDocument<C extends CollectionName> = Collections[C]`
  )
  lines.push(
    `export type SingletonDocument<S extends SingletonName> = Singletons[S]`
  )
  lines.push('')

  // AllDocuments union type for load() API
  const allTypes: string[] = []
  for (const col of collections) {
    allTypes.push(`${col.interfaceName}Fields`)
  }
  for (const singleton of singletons) {
    allTypes.push(`${singleton.interfaceName}Fields`)
  }

  if (allTypes.length > 0) {
    lines.push(`/** Union of all document field types for use with load() */`)
    lines.push(`export type AllDocuments = ${allTypes.join(' | ')}`)
  } else {
    lines.push(`/** Union of all document field types for use with load() */`)
    lines.push(`export type AllDocuments = {}`)
  }
  lines.push('')

  return lines.join('\n')
}

/**
 * Generates the api.d.ts file with typed overloads
 */
function generateApiFile(
  collections: CollectionInfo[],
  singletons: CollectionInfo[]
): string {
  const hasCollections = collections.length > 0
  const hasSingletons = singletons.length > 0
  const lines: string[] = []

  lines.push(`// Generated by Outstatic - do not edit manually`)
  lines.push(
    `// This file provides typed overloads for Outstatic server functions`
  )
  lines.push('')
  lines.push(
    `import type { CollectionName, CollectionDocument, SingletonName, SingletonDocument, AllDocuments } from './collections'`
  )

  // Import Fields types for each collection
  for (const col of collections) {
    lines.push(
      `import type { ${col.interfaceName}Fields } from './${col.slug}'`
    )
  }

  // Import Fields types for each singleton
  for (const singleton of singletons) {
    lines.push(
      `import type { ${singleton.interfaceName}Fields } from './_singletons/${singleton.slug}'`
    )
  }

  lines.push(`import type { OutstaticSchema } from 'outstatic'`)
  lines.push(`import type { Query } from 'sift'`)
  lines.push('')

  // Generate FindAPI type
  lines.push(`/** Fluent API for querying documents */`)
  lines.push(`interface FindAPI<T, P = T> {`)
  lines.push(`  /** Sort results by field(s) */`)
  lines.push(
    `  sort(sort: { [K in keyof T]?: 1 | -1 } | (keyof T)[] | keyof T): FindAPI<T, P>`
  )
  lines.push(
    `  /** Select fields to return (use 'as const' for type narrowing) */`
  )
  lines.push(
    `  project<K extends keyof T>(projection: readonly K[]): FindAPI<T, Pick<T, K>>`
  )
  lines.push(
    `  project(projection: Record<string, number>): FindAPI<T, Partial<T>>`
  )
  lines.push(`  /** Skip N results */`)
  lines.push(`  skip(skip: number): FindAPI<T, P>`)
  lines.push(`  /** Limit to N results */`)
  lines.push(`  limit(limit: number): FindAPI<T, P>`)
  lines.push(`  /** Get first result */`)
  lines.push(`  first(): Promise<P | undefined>`)
  lines.push(`  /** Get all results as array */`)
  lines.push(`  toArray(): Promise<P[]>`)
  lines.push(`}`)
  lines.push('')

  // Generate collection to fields type mapping
  if (hasCollections) {
    lines.push(
      `/** Infers the document type from a query's collection property */`
    )
    lines.push(`type InferDocumentType<Q> =`)
    // Generate explicit checks for each collection to ensure literal types are preserved
    for (const col of collections) {
      lines.push(
        `  Q extends { collection: '${col.slug}' } ? OutstaticSchema<${col.interfaceName}Fields> :`
      )
    }
    lines.push(`  OutstaticSchema<AllDocuments>`)
    lines.push('')
  }

  // Generate LoadAPI type with overloads
  lines.push(`/** API returned by load() */`)
  lines.push(`interface LoadAPI {`)

  if (hasCollections) {
    // Collection-specific overloads with projection narrowing (most specific - checked first)
    for (const col of collections) {
      // Overload with projection array that narrows return type (requires 'as const')
      lines.push(
        `  /** Find ${col.slug} documents with field projection (use 'as const' for type narrowing) */`
      )
      lines.push(
        `  find<K extends keyof OutstaticSchema<${col.interfaceName}Fields>>(`
      )
      lines.push(
        `    query: { collection: '${col.slug}' } & Record<string, unknown>,`
      )
      lines.push(`    projection: readonly K[]`)
      lines.push(
        `  ): FindAPI<OutstaticSchema<${col.interfaceName}Fields>, Pick<OutstaticSchema<${col.interfaceName}Fields>, K>>`
      )
      lines.push(``)
      // Overload with string[] projection (no narrowing)
      lines.push(`  /** Find ${col.slug} documents */`)
      lines.push(`  find(`)
      lines.push(
        `    query: { collection: '${col.slug}' } & Record<string, unknown>,`
      )
      lines.push(`    projection: string[]`)
      lines.push(`  ): FindAPI<OutstaticSchema<${col.interfaceName}Fields>>`)
      lines.push(``)
      // Overload without projection or with object projection
      lines.push(`  /** Find ${col.slug} documents */`)
      lines.push(`  find(`)
      lines.push(
        `    query: { collection: '${col.slug}' } & Record<string, unknown>,`
      )
      lines.push(`    projection?: { [key: string]: number }`)
      lines.push(`  ): FindAPI<OutstaticSchema<${col.interfaceName}Fields>>`)
      lines.push(``)
    }
    // Generic fallback with projection narrowing (requires 'as const')
    lines.push(
      `  /** Find documents with field projection (use 'as const' for type narrowing) */`
    )
    lines.push(`  find<K extends keyof OutstaticSchema<AllDocuments>>(`)
    lines.push(`    query: Record<string, unknown>,`)
    lines.push(`    projection: readonly K[]`)
    lines.push(
      `  ): FindAPI<OutstaticSchema<AllDocuments>, Pick<OutstaticSchema<AllDocuments>, K>>`
    )
    lines.push(``)
    // Generic fallback with string[] projection (no narrowing)
    lines.push(`  /** Find documents matching a query */`)
    lines.push(`  find(`)
    lines.push(`    query: Record<string, unknown>,`)
    lines.push(`    projection: string[]`)
    lines.push(`  ): FindAPI<OutstaticSchema<AllDocuments>>`)
    lines.push(``)
    // Generic fallback for queries without projection
    lines.push(`  /** Find documents matching a query */`)
    lines.push(`  find(`)
    lines.push(`    query: Record<string, unknown>,`)
    lines.push(`    projection?: { [key: string]: number }`)
    lines.push(`  ): FindAPI<OutstaticSchema<AllDocuments>>`)
    lines.push(``)
    // Overload for explicit type parameter (user-specified return type)
    lines.push(`  /** Find documents with explicit return type */`)
    lines.push(`  find<T>(`)
    lines.push(`    query: Record<string, unknown>,`)
    lines.push(`    projection?: string[] | { [key: string]: number }`)
    lines.push(`  ): FindAPI<T>`)
  } else {
    lines.push(`  find<T = OutstaticSchema<AllDocuments>>(`)
    lines.push(`    query: Query<OutstaticSchema<AllDocuments>>,`)
    lines.push(`    projection?: string[] | { [key: string]: number }`)
    lines.push(`  ): FindAPI<T>`)
  }

  lines.push(`}`)
  lines.push('')

  lines.push(`declare module 'outstatic/server' {`)

  if (hasCollections) {
    // getDocuments overload
    lines.push(`  /**`)
    lines.push(`   * Get all documents from a collection`)
    lines.push(`   * @param collection - The collection name`)
    lines.push(
      `   * @param fields - Optional array of fields to include (use 'as const' for type narrowing)`
    )
    lines.push(`   */`)
    lines.push(`  export function getDocuments<`)
    lines.push(`    C extends CollectionName,`)
    lines.push(
      `    F extends readonly (keyof CollectionDocument<C>)[] | undefined = undefined`
    )
    lines.push(`  >(`)
    lines.push(`    collection: C,`)
    lines.push(`    fields?: F`)
    lines.push(`  ): F extends readonly (keyof CollectionDocument<C>)[]`)
    lines.push(`    ? Pick<CollectionDocument<C>, F[number]>[]`)
    lines.push(`    : CollectionDocument<C>[]`)
    lines.push('')

    // getDocumentBySlug overload
    lines.push(`  /**`)
    lines.push(`   * Get a single document by its slug`)
    lines.push(`   * @param collection - The collection name`)
    lines.push(`   * @param slug - The document slug`)
    lines.push(
      `   * @param fields - Optional array of fields to include (use 'as const' for type narrowing)`
    )
    lines.push(`   */`)
    lines.push(`  export function getDocumentBySlug<`)
    lines.push(`    C extends CollectionName,`)
    lines.push(
      `    F extends readonly (keyof CollectionDocument<C>)[] | undefined = undefined`
    )
    lines.push(`  >(`)
    lines.push(`    collection: C,`)
    lines.push(`    slug: string,`)
    lines.push(`    fields?: F`)
    lines.push(`  ): F extends readonly (keyof CollectionDocument<C>)[]`)
    lines.push(`    ? Pick<CollectionDocument<C>, F[number]> | null`)
    lines.push(`    : CollectionDocument<C> | null`)
    lines.push('')

    // getDocumentSlugs overload
    lines.push(`  /**`)
    lines.push(`   * Get all document slugs from a collection`)
    lines.push(`   * @param collection - The collection name`)
    lines.push(`   */`)
    lines.push(
      `  export function getDocumentSlugs(collection: CollectionName): string[]`
    )
    lines.push('')

    // getDocumentPaths overload
    lines.push(`  /**`)
    lines.push(`   * Get document paths for static generation`)
    lines.push(`   * @param collection - The collection name`)
    lines.push(`   */`)
    lines.push(
      `  export function getDocumentPaths(collection: CollectionName): { params: { slug: string } }[]`
    )
    lines.push('')
  }

  // Singleton APIs
  if (hasSingletons) {
    // getSingletonBySlug overload
    lines.push(`  /**`)
    lines.push(`   * Get a singleton by its slug`)
    lines.push(`   * @param slug - The singleton slug`)
    lines.push(
      `   * @param fields - Optional array of fields to include (use 'as const' for type narrowing)`
    )
    lines.push(`   */`)
    lines.push(`  export function getSingletonBySlug<`)
    lines.push(`    S extends SingletonName,`)
    lines.push(
      `    F extends readonly (keyof SingletonDocument<S>)[] | undefined = undefined`
    )
    lines.push(`  >(`)
    lines.push(`    slug: S,`)
    lines.push(`    fields?: F`)
    lines.push(`  ): F extends readonly (keyof SingletonDocument<S>)[]`)
    lines.push(`    ? Pick<SingletonDocument<S>, F[number]> | null`)
    lines.push(`    : SingletonDocument<S> | null`)
    lines.push('')

    // getSingletonSlugs overload
    lines.push(`  /**`)
    lines.push(`   * Get all singleton slugs`)
    lines.push(`   */`)
    lines.push(`  export function getSingletonSlugs(): SingletonName[]`)
    lines.push('')
  }

  // load overload - works with all documents
  lines.push(`  /**`)
  lines.push(`   * Load the metadata database for advanced querying`)
  lines.push(
    `   * @returns LoadAPI with typed find method that narrows based on collection query`
  )
  lines.push(`   */`)
  lines.push(`  export function load(): Promise<LoadAPI>`)

  lines.push(`}`)
  lines.push('')

  return lines.join('\n')
}

/**
 * Generates the index.ts file that re-exports all types
 */
function generateIndexFile(
  collections: CollectionInfo[],
  singletons: CollectionInfo[]
): string {
  const lines: string[] = []

  lines.push(`// Generated by Outstatic - do not edit manually`)
  lines.push(`// Re-exports all generated types`)
  lines.push('')

  // Re-export collections module
  lines.push(`export * from './collections'`)
  lines.push('')

  // Re-export each collection type
  for (const col of collections) {
    lines.push(`export * from './${col.slug}'`)
  }

  // Re-export each singleton type
  for (const singleton of singletons) {
    lines.push(`export * from './_singletons/${singleton.slug}'`)
  }

  lines.push('')

  return lines.join('\n')
}

/**
 * Ensures a directory exists, creating it if necessary
 */
function ensureDir(dirPath: string): void {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true })
  }
}

/**
 * Main type generation function
 */
export function generateTypes(options: GenerateTypesOptions = {}): void {
  const now = Date.now()
  const cwd = options.cwd || process.cwd()
  const contentPath = path.join(
    cwd,
    options.contentPath || DEFAULT_CONTENT_PATH
  )
  const outputPath = path.join(cwd, options.outputPath || DEFAULT_OUTPUT_PATH)

  // Discover collections and singletons
  const collections = discoverCollections(contentPath)
  const singletons = discoverSingletons(contentPath)

  if (collections.length === 0 && singletons.length === 0) {
    console.log('No collections or singletons found. Skipping type generation.')
    return
  }

  // Ensure output directories exist
  ensureDir(outputPath)
  if (singletons.length > 0) {
    ensureDir(path.join(outputPath, '_singletons'))
  }

  // Generate type files for collections
  for (const col of collections) {
    const content = generateTypeFile(col)
    fs.writeFileSync(path.join(outputPath, `${col.slug}.ts`), content)
  }

  // Generate type files for singletons
  for (const singleton of singletons) {
    const content = generateTypeFile(singleton)
    fs.writeFileSync(
      path.join(outputPath, '_singletons', `${singleton.slug}.ts`),
      content
    )
  }

  // Generate collections.ts
  const collectionsContent = generateCollectionsFile(collections, singletons)
  fs.writeFileSync(path.join(outputPath, 'collections.ts'), collectionsContent)

  // Generate api.d.ts
  const apiContent = generateApiFile(collections, singletons)
  fs.writeFileSync(path.join(outputPath, 'api.d.ts'), apiContent)

  // Generate index.ts
  const indexContent = generateIndexFile(collections, singletons)
  fs.writeFileSync(path.join(outputPath, 'index.ts'), indexContent)

  console.log(
    `âœ“ Generated Outstatic types for ${collections.length} collection${
      collections.length === 1 ? '' : 's'
    } and ${singletons.length} singleton${
      singletons.length === 1 ? '' : 's'
    } in ${(Date.now() - now).toFixed(1)}ms`
  )
}

/**
 * Synchronous version for use in next.config.js
 */
export function generateTypesSync(options: GenerateTypesOptions = {}): void {
  generateTypes(options)
}

/**
 * Watch for schema changes and regenerate types
 */
export async function watchSchemas(
  options: GenerateTypesOptions = {}
): Promise<void> {
  const cwd = options.cwd || process.cwd()
  const contentPath = path.join(
    cwd,
    options.contentPath || DEFAULT_CONTENT_PATH
  )

  // Initial generation
  generateTypes(options)

  // Try to use @parcel/watcher for efficient watching
  try {
    const watcher = await import('@parcel/watcher')

    console.log(`Watching for schema changes in ${contentPath}...`)

    await watcher.subscribe(contentPath, (err, events) => {
      if (err) {
        console.error('Watch error:', err)
        return
      }

      // Check if any schema files changed
      const schemaChanged = events.some(
        (event) =>
          event.path.endsWith('schema.json') ||
          event.path.endsWith('.schema.json')
      )

      if (schemaChanged) {
        console.log('Schema change detected, regenerating types...')
        generateTypes(options)
      }
    })
  } catch (e) {
    // Fallback to fs.watch if @parcel/watcher is not available
    console.log(
      'Using fs.watch for schema watching (install @parcel/watcher for better performance)'
    )

    const debounce = (fn: () => void, ms: number) => {
      let timeout: NodeJS.Timeout
      return () => {
        clearTimeout(timeout)
        timeout = setTimeout(fn, ms)
      }
    }

    const regenerate = debounce(() => {
      console.log('Schema change detected, regenerating types...')
      generateTypes(options)
    }, 100)

    fs.watch(contentPath, { recursive: true }, (eventType, filename) => {
      if (
        filename &&
        (filename.endsWith('schema.json') || filename.endsWith('.schema.json'))
      ) {
        regenerate()
      }
    })
  }
}
